\documentclass[arbeit=studie,oneside,BCOR=12mm]{ArbeitRST}
% Die Option BCOR legt den Rand für die Bindekorrektur links fest
% (verschiebt das ganze Dokument nach rechts auf dem Papier, damit
% Platz zum Binden ist

% bib-Datei mit den Literaturangaben
% ==================================
\addbibresource{Literaturverzeichnis.bib}


\usepackage{physics}
\usepackage{amsmath}
\usepackage{csvsimple}
\usepackage{mathtools}


% Zwei Parameter zum Verändern des Layouts
% ========================================
% \parindent -> Legt fest, mit welcher Einrückung jeder neue
%               Absatz beginnen soll
% \parskip -> Legt fest, wieviel vertikaler Abstand zwischen zwei
%             Absätzen liegen soll
%
% Tipp: Entweder parindent auf Null und parskip auf einen Wert
% ungleich Null (z.B. 2ex) oder umgekehrt. Beide Werte ungleich
% Null macht satztechnisch keinen Sinn. 1ex = Breite des 
% Buchstabens x
\setlength{\parindent}{0ex}
\setlength{\parskip}{2ex}



% Einige Einstellungen für das hyperref-Paket
% =========================================== 
% Hiermit können Links, Gleichungsnummern etc. farbig dargestellt
% werden was die Navigation im elektronischen Dokument vereinfacht. An
% dieser Stelle können Sie die Farbgebung anpassen. Druckversion bitte
% ohne farbige Links erstellen, siehe Option unten!
\hypersetup{
    unicode=false,          % non-Latin characters in Acrobat’s bookmarks
    pdftoolbar=true,        % show Acrobat’s toolbar?
    pdfmenubar=true,        % show Acrobat’s menu?
    pdffitwindow=false,     % window fit to page when opened
    pdfstartview={FitH},    % fits the width of the page to the window
    pdftitle={RST Vorlage}, % title
    pdfauthor={Author},     % author
    pdfsubject={Subject},   % subject of the document
    pdfcreator={Creator},   % creator of the document
    pdfproducer={Producer}, % producer of the document
    pdfkeywords={keyword1} {key2} {key3}, % list of keywords
    pdfnewwindow=true,      % links in new window
    colorlinks=true,        % false: boxed links; true: colored links
    linkcolor=blue,         % color of internal links (change box color with linkbordercolor)
    citecolor=green,        % color of links to bibliography
    filecolor=magenta,      % color of file links
    urlcolor=cyan           % color of external links
}

% Entfernt die farbigen Markierungen - bitte Druckversion mit dieser Option kompilieren
%\hypersetup{hidelinks}

   

% =================================================================
\begin{document}

% Titelseite
% ==========

% Name des Verfassers
\author{Julius Fiedler}

% Geburtsort
\geburtsort{Dresden}

% Geburtsdatum
\geburtsdatum{13. Oktober 1996}

% Titel der Arbeit
\title{Über den Einfluss hochfrequenter mechanischer Oszillationen auf das Schaltverhalten supraleitender PID-Regler auf Quantenbasis}

% Untertitel
\subtitle{Eine Fallstudie unter besonderer Berücksichtigung stochastischer Einflüsse}

% Angabe der Betreuer
\betreuer{Betreuer 1}
\betreuer{Betreuer 2}

% Datum der Einreichung
\date{2. Februar 2222}


% Zunächst für das Vorgeplänkel römische Seitenzahlen und einfacher Seitenstil
% ============================================================================
\pagenumbering{Roman}
\pagestyle{plain}


% Titelseite erstellen
\maketitle


% Selbstständigkeitserklärung
% ===========================

% Ort der Selbstständigkeitserklärung (Standard: Dresden)
\selbstort{Pirna}

% Datum der Selbstständigkeitserklärung (Standard: aktuelles Systemdatum)
\selbstdatum{1. Januar 2016}

% Selbstständigkeitserklärung erstellen
\selbststaendigkeitserklaerung


% Kurzfassung / Abstract
% ======================
\kurzfassung{An dieser Stelle fügen Sie bitte eine deutsche Kurzfassung ein.}{Please insert the English abstract here.}


% Inhaltsverzeichnis
% ==================
\tableofcontents

% Ggf. Symbolverzeichnis
% ======================
\input{symbolverzeichnis}

% Ggf. Abbildungsverzeichnis
% ==========================
\listoffigures


% Ggf. Tabellenverzeichnis
% ========================
\listoftables


% ========================
% Beginn Inhalt der Arbeit
% ========================

% Inhalt kann entweder in separate LaTeX-Dateien ausgelagert werden
% (hier: inhalt.tex) und dann mittels \input{} geladen werden...
% Darauf achten, dass pagenumbering und pagestyle richtig gesetzt werden
% (siehe Einträge in inhalt.tex)


%\input{inhalt}

\pagenumbering{arabic}
% ...oder man schreibt direkt in dieser Datei (weniger übersichtlich)


% Ab hier Reinschrift
\chapter{Der SINDy-Algorithmus}

\section{Idee}
\input{Sindy_einleitung.tex}
\section{Funktionsweise der Methode}
\input{Funktionsweise_Sindy.tex}
Der SINDy-Algorithmus wurde sowohl in Python durch die Bibliothek PySindy \cite{Silva2020} als auch in Julia durch die Bibliothek DataDrivenDiffEq implementiert. Im Verlauf dieser Arbeit ist ein vereinfachter SINDy-Algorithmus entstanden, der mit den existierenden Implementationen verglichen werden soll.
\section{Lösen des Minimierungsproblems}
\input{MKQ.tex}
%\section{Grenzen der Methode} 

\chapter{Vergleich der Implementationen}
\input{Vergleich_einleitung.tex}











\chapter{Notizen}
inhaltlich noch zu verarbeitende Punkte:
identification with prior knowledge
reibung
rauschen
vergleichsparameter: tspan, dt, u0, (lambda), multra, p?
NN



\section{UDE}

\begin{figure}[ht]
\begin{subfigure}[c]{0.5\textwidth}
\centering
\includegraphics[width=1\textwidth]{images/arctan_1x_order_100}

\end{subfigure}
\begin{subfigure}[c]{0.5\textwidth}
\centering
\includegraphics[width=1\textwidth]{images/arctan_10x_order_100}

\end{subfigure}
\begin{subfigure}[c]{0.5\textwidth}
\centering
\includegraphics[width=1\textwidth]{images/tanh_1x_order_100}

\end{subfigure}
\begin{subfigure}[c]{0.5\textwidth}
\centering
\includegraphics[width=1\textwidth]{images/tanh_10x_order_100}

\end{subfigure}
\end{figure}


\subsection{8.7.20} 
überlegung NN in julia und sindy in python machen, export erledigt\\
trotzdem keine identifikation in python möglich, grund: zu wenig daten (datenfeld mit 31 daten Autflösung viel zu gering)\\
bei erhöhung der auflösung wird trainingszeit enorm groß
NN approximiert den verlauf der ableitungen	\\
sindy mal mit anderen anfangswerten trainieren
\subsection{9.7.20}
ude keine option für multiple trajectories / threshhold???
\subsubsection{ude + sindy}
definitorische Gleichungen bekannt\\
dt=0.1\\
sindy did not converge
\begin{align}
du_1 &= cos(u_3) * p_1\\
du_2 &= sin(u_3) * p_2\\
du_3 &= sin(u_1) * p_3 + p_4 * u_1\\
du_4 &= sin(u_3) * p_5
\end{align}
parameters: Float32[0.050624948, 0.006272168, -20.755184, -13.720979, -0.01513608]
\includegraphics[width=1\textwidth]{images/ude_ident_with_prior_knowledge}
im Vergleich: nur den Sindy Part in PySindy ausgelagert ergibt: (dieser Vergleich ist nicht sinnvoll? pysindy kennt ja die def. gl nicht)
\begin{align*}
phi' &= 65170415.755 xdot + -72812822.138 sin(xdot) + 2647179.524 cos(xdot)\\
x' &= 51018334.340 xdot + -57002163.483 sin(xdot) + 2072882.755 cos(xdot)\\
phidot' &= -3.002 phi + -6.328 x + 2682545588.568 xdot + -33.032 sin(phi) \\&+ -1.358 sin(x) + -0.208 sin(phidot) + -2997205703.337 sin(xdot) \\&+ -0.020 cos(phi) + -6.583 cos(x) + 109008747.059 cos(xdot)\\
xdot' &= 0.320 x + -18300414.600 xdot + 20447317.167 sin(xdot) + 0.344 cos(x) \\&+ -743815.199 cos(xdot)
\end{align*}




keine Gleichungen bekannt\\
dt=0.1\\
sindy did not converge
\begin{align}
du_1 &= p_1 * u_3\\
du_2 &= sin(u_2) * p_2\\
du_3 &= sin(u_1) * p_3 + p_4 * u_1\\
du_4 &= cos(u_1) * p_5
\end{align}
parameters: Float32[0.997858, 0.20674846, -18.494001, -15.788721, 0.040644586]\\
\includegraphics[width=1\textwidth]{images/ude_ident_without_prior_knowledge}
im Vergleich: nur den Sindy Part in PySindy ausgelagert ergibt:
\begin{align*}
phi' &= 1.111 phi + 0.648 x + 1.002 phidot + -503701656.178 xdot + -1.228 sin(phi) \\&+ 562779966.638 sin(xdot) + -0.050 cos(phi) + 0.676 cos(x) + -20465608.922 cos(xdot)\\
x' &= 0.833 phi + -0.031 x + 450669011.982 xdot + -0.967 sin(phi) \\&+ -503527393.951 sin(xdot) + 0.157 cos(phi) + -0.051 cos(x) + 18310968.307 cos(xdot)\\
phidot' &= -2.551 phi + -4.834 x + -3252316739.183 xdot + -33.509 sin(phi) \\&+ -0.458 sin(x) + 3633781720.861 sin(xdot) + -5.066 cos(x) + -132146405.440 cos(xdot)\\
xdot' &= 0.674 phi + -184783222.592 xdot + -0.759 sin(phi) + 206455836.816 sin(xdot) + \\&-7507657.694 cos(xdot)
\end{align*}

\subsubsection{ude reibung}
tanh wie erwartet problematisch, vmtl sinnvoll tanh vorzugeben\\
viskose+ haftreibung:
\begin{align*}
du_1 &= sin(u_3) * p_1\\
du_2 &= cos(u_1) * p_2 + cos(u_3) * p_3\\
du_3 &= p_4 * u_3\\
du_4 &= sin(u_3) * p_5
\end{align*}
parameters: Float32[-0.032978103, 0.020778582, 0.02180107, -0.30371103, -0.026243187]
\includegraphics[width=1\textwidth]{images/ude_fric_order_4}

nur viskose reibung, order 2:\\
\begin{align*}
d_1&=0.3\\
d_{1, ident}&= 0.2981498
\end{align*}

\begin{figure}
\includegraphics[width=1\textwidth]{images/ude_fric_viskos_d1_03}
\caption{ude fric viskos d1 03}
\end{figure}

viskose + haftreibung: order 1, tanh vorgegeben:\\
\begin{align*}
du_1 &= cos(u_1) * p_1\\
du_2 &= sin(u_3) * p_2\\
du_3 &= tanh(10u_3) * p_3 + p_4 * u_3\\
du_4 &= tanh(10u_3) * p_5
\end{align*}
parameters: Float32[0.018757716, -0.011911368, -0.26272112, -0.35348737, -0.005909097]

\begin{figure}
\includegraphics[width=1\textwidth]{images/ude_fric_viskos_d1_03_d2_05}
\caption{ude fric viskos und haft d1 03 d2 05}
\end{figure}


\subsubsection{Pysindy reibung}
Ansatz: Sindy für Differenz von Realem Modell mit Reibung und theoretischem Modell verwenden, siehe Bsp:\\
\begin{figure}
\begin{subfigure}[c]{0.5\textwidth}
\includegraphics[width=1\textwidth]{images/pysindy_fric_visk2}
\end{subfigure}
\begin{subfigure}[c]{0.5\textwidth}
\includegraphics[width=1\textwidth]{images/pysindy_fric_visk1}
\end{subfigure}
\caption{nur viskose Reibung}
\end{figure}
keine Identifikation feststellbar\\
vermutung: aus Differenz geht keine exp funktion hervor, es fehlt die info über das vorherige System
idee: prior system knowledge integrieren indem man das bekannte teilsystem aus library funktion zur verfügung stellt
\section{Sindy}
\subsection{Funktionsweise der Methode}
Sparse Identification of Nonlinear Dynamics (SINDy) ist eine Methode, um aus Messdaten eines Systems dessen Systemdifferentialgleichungen zu schätzen.\\
Sei $x(t)\in\mathbb{R}^n$ der Zustandsvektor mit $x(t) = [x_1(t), x_2(t), ... , x_n(t)]$. Gesucht ist die Funktion der zeitlichen Ableitung des Zustandes $\dv{x(t)}{t} = f(x(t))$, welche auch nichtlinear sein kann. %d/dt gut so?
Die zugrundeliegende Überlegung der Methode ist, dass die Funktion $f$ in einem geeigneten Raum an Basisfunktionen oft \textit{dünn besetzt} ist. Betrachtet man beispielsweise die Funktion
\begin{equation}
\dv{x}{t} = f(x) = \begin{bmatrix} f_1(x)\\ f_2(x)\\ \end{bmatrix}
=\begin{bmatrix} 1+2x_1+x_1x_2^2 \\ x_1^3-3x_2\\ \end{bmatrix}
\end{equation}
so ist leicht zu erkennen, dass $f$ in Bezug auf die Basis von Polynomen aus zwei Variablen (z.B. $f_1(x)=\sum_{i=0}^{\infty}\sum_{j=0}^{\infty}a_{ij}x_1^ix_2^j$) dünn besetzt ist. Nur eine sehr geringe Zahl der Koeffizienten $a_{ij}$ ist ungleich null.
SINDy versucht nun mittels Regression diejenigen Monome auszuwählen, die die Funktion $f$ am besten repräsentieren können.\\
Für die Anwendung von SINDy benötigt man die Messdaten aller Zustandsgrößen zu den Zeitpunkten $t_1, t_2, ..., t_m)$. Zusätzlich müssen die zeitlichen Ableitungen der Zustände an den gegebenen Zeitpunkten gegeben sein, entweder durch direkte Messung oder durch numerische Approximation. Die Daten werden wie folgt angeordnet: 
\begin{align}
X &= \begin{bmatrix}
		x_1(t_1) & x_2(t_1) & \dots & x_n(t_1) \\
		x_1(t_2) & x_2(t_2) & \dots & x_n(t_2) \\
		\vdots   & \vdots   & 		& \vdots \\ 
		x_1(t_m) & x_2(t_m) & \dots & x_n(t_m)
	\end{bmatrix} \in \mathbb{R}^{m\times n},
	\\
	\dot{X} &= \begin{bmatrix} 
		\dot{x_1}(t_1) & \dot{x_2}(t_1) & \dots & \dot{x_n}(t_1) \\
		\dot{x_1}(t_2) & \dot{x_2}(t_2) & \dots & \dot{x_n}(t_2) \\
		\vdots 		   & \vdots 		& 		& \vdots \\
		\dot{x_1}(t_m) & \dot{x_2}(t_m) & \dots & \dot{x_n}(t_m)
	\end{bmatrix}  \in \mathbb{R}^{m\times n}.
\end{align}
Nun muss man die Bibliothek $\Theta$ an Funktionen konstruieren, durch welche $f$ dargestellt werden soll. Hier ist es günstig, wenn man bereits weiß, welche Funktionsklassen in $f$ vorkommen, um die Bibliothek geeignet auszulegen.
Die Spalten der Bibliotheksmatrix repräsentieren die gewählten Ansatzfunktionen, angewendet auf die Datenmatrix $X$ 
\begin{equation}
\Theta(X) = \begin{bmatrix}
		\mid & \mid & & \mid \\
		\theta_1(X) & \theta_2(X) & \dots & \theta_\ell(X) \\
		\mid & \mid & & \mid 
	\end{bmatrix}\in\mathbb{R}^{m\times L}.
\end{equation} 
Wählt man beispielsweise für $\theta_1$ die Sinusfunktion und für $\theta_2$ Monome zweiten Grades so ergeben sich 
\begin{align}
\theta_1(X) &= \begin{bmatrix}
		\mid 	  & \mid     		  &          & \mid             \\
		\sin(x_1(t)) & \sin(x_2(t))   & \dots    & \sin(x_n(t)) \\
		\mid      & \mid     		  &          & \mid              
	\end{bmatrix},\\
\theta_2(X) &= \begin{bmatrix}
		\mid & \mid & & \mid & \mid & & \mid \\
		x_1(t)^2 & x_1(t)x_2(t) & \dots & x_2(t)^2 & x_2(t)x_3(t) & \dots & x_n^2(t) \\
		\mid & \mid & & \mid & \mid & & \mid
	\end{bmatrix},	
\end{align}
wobei die Rechenoperationen alle elementweise zu lesen sind. \\
Gesucht sind nun Linearkombinationen von Bibliotheksfunktionen, sodass gilt
\begin{equation}
f_i(x) = \Theta(x^T)\xi_i.
\end{equation}
Fasst man alle $\xi_i$ in eine Koeffizientenmatrix $\Xi\in\mathbb{R}^{L\times n}$ zusammen, so ergibt sich das zu lösende Problem zu 
\begin{equation}
\dot{X} \approx \Theta(X)\Xi.
\end{equation}
\cite{Silva2020}
In der Praxis sollte dieses Gleichungssystem überbestimmt sein. Das bedeutet, dass die Anzahl der Messzeitpunkte $m$ (die Anzahl der Zeilen) größer ist als die Anzahl der Einträge in $\Xi\in\mathbb{R}^{L\times n}$ (Anzahl der Unbekannten). Um das SINDy-Problem zu lösen, wird die Methode der kleinsten Quadrate angewendet. Durch aufstellen der Pseudo-Inversen ergibt sich

\begin{equation}
\dot{X} \approx \Theta(X)\Xi
\end{equation}
Intuitively, I would solve this by using the pseudo-inverese 
\begin{equation}
\Xi = \left(\Theta(X)\right)^+\dot{X}.
\end{equation}
With $\Theta(X)$ having full collumn rank, we get
\begin{equation}
\Xi = \left(\Theta(X)^T\Theta(X)\right)^{-1}\Theta(X)^T\dot{X}.\label{eq:intuitiv}
\end{equation}
But in the code implemented is the following equation: 

\begin{equation}
\Xi_\text{new} = \left(\Theta(X)^T\Theta(X) + I \right)^{-1} \left(\Theta(X)^T\dot{X} + \Xi_{\text{old}} \right)\label{eq:code}
\end{equation}
with the first coefficient matrix being
\begin{equation}
\Xi_\text{old, 0} = \left(\Theta^T\Theta\right)^{-1}\Theta^T \dot{X}.
\end{equation}
What is the reasoning behind using \ref{eq:code} over the more intuitive \ref{eq:intuitiv}? (I do understand the motivation behind repeating the calculation and successively eliminating small coefficients, but why do you use this formula?)

Additionally I noted that using
\begin{equation}
\Theta^T\dot{X} \approx \Theta^T\Theta\Xi_\text{old}
\end{equation}
we can simplify \ref{eq:code}
\begin{equation}
\begin{aligned}
\Xi_\text{new} &= \left(\Theta^T\Theta + I \right)^{-1} \left(\Theta^T\Theta\Xi_\text{old} + \Xi_\text{old} \right)\\
&\approx\left(\Theta^T\Theta + I \right)^{-1} \left(\Theta^T\Theta+I\right)\Xi_\text{old} \\
&\approx\Xi_\text{old}
\end{aligned}
\end{equation}

which seems odd to me.


iterieren und am Ende
%\begin{equation}
%\dot{X}[:,i] = \Theta_k(X) \xi_i
%\end{equation}


initial guess: Solves the equation $a x = b$ by computing a vector $x$ that
    minimizes the squared Euclidean 2-norm $\| b - a x \|^2_2$.
    The equation may be under-, well-, or over-determined (i.e., the
    number of linearly independent rows of $a$ can be less than, equal
    to, or greater than its number of linearly independent columns).
    If $a$ is square and of full rank, then $x$ (but for round-off error)
    is the "exact" solution of the equation.

\subsection{Vergleich von SINDY-Implementierungen in Python (PySindy) und Julia (DiffEqLibrary)}
System: Volterra DGL
\begin{align}
\dot{x} &= \alpha x +\beta xy\\
\dot{y} &= \gamma y + \delta xy 
\end{align}
mit $[\alpha, \beta, \gamma, \delta] = [1.3, -0.9, -1.8, 0.8]$\\
Zeitspanne 3s\\
Schrittweite 0.1s\\
Polynomial Library Order 2\\
nicht normalisiert\\
maximale Iterationen: 30\\
Threshold 0.2\\
Datenerzeugung durch Lösen der DGL mittels DGL-Solver, Verwendung der exakt gleichen Datensätze in beiden Algorithmen\\
Fall 1: exakte Ableitungen bekannt\\
\begin{tabular}[h]{c|c|c|c}
Parameter 	& Nominal 	& DiffEq		& PySindy 	\\\hline
$\alpha$ 	&  	 1.3	& 	1.291		&	1.300		\\\hline
$\beta$ 	&  	-0.9	& 	-0.850		&	-0.900		\\\hline
$\gamma$ 	&  	 -1.8	& 	-1.801		&	-1.800		\\\hline
$\delta$ 	&  	0.8		& 	0.753		&	0.800		\\
\end{tabular}

Fall 2: Zentraldifferenz für Ableitungen verwendet\\
\begin{tabular}[h]{c|c|c|c}
Parameter 	& Nominal 	& DiffEq		& PySindy 	\\\hline
$\alpha$ 	&  	 1.3	& 	1.301		&	1.302		\\\hline
$\beta$ 	&  	-0.9	& 	-0.683		&	-0.903		\\\hline
$\gamma$ 	&  	 -1.8	& 	-1.816		&	-1.802		\\\hline
$\delta$ 	&  	0.8		& 	0.614		&	0.798		\\
\end{tabular}

Fall 3: Ableitungen durch Neuronales Netz gelernt, gleiche Auflösung\\
\begin{tabular}[h]{c|c|c|c}
Parameter 	& Nominal 	& DiffEq		& PySindy 	\\\hline
$\alpha$ 	&  	 1.3	& 	1.438		&	1.289		\\\hline
$\beta$ 	&  	-0.9	& 	-0.226		&	-0.868		\\\hline
$\gamma$ 	&  	 -1.8	& 	-1.814		&	-1.780		\\\hline
$\delta$ 	&  	0.8		& 	0.386		&	0.721		\\
\end{tabular}

Fall 4: Ableitungen durch Neuronales Netz gelernt, Schrittweite 0.01s (NN auf wenig Daten trainiert, viele Daten abgerufen)\\
\begin{tabular}[h]{c|c|c|c}
Parameter 	& Nominal 	& DiffEq		& PySindy 	\\\hline
$\alpha$ 	&  	 1.3	& 	1.471		&	1.294		\\\hline
$\beta$ 	&  	-0.9	& 	-0.353		&	-0.887		\\\hline
$\gamma$ 	&  	 -1.8	& 	-1.818		&	-1.786		\\\hline
$\delta$ 	&  	0.8		& 	0.473		&	0.744		\\
\end{tabular}

Fall 5: Ableitungen durch Neuronales Netz gelernt, Schrittweite 0.001s (NN auf wenig Daten trainiert, viele Daten abgerufen)\\
\begin{tabular}[h]{c|c|c|c}
Parameter 	& Nominal 	& DiffEq		& PySindy 	\\\hline
$\alpha$ 	&  	 1.3	& 	1.477		&	1.294		\\\hline
$\beta$ 	&  	-0.9	& 	-0.367		&	-0.889		\\\hline
$\gamma$ 	&  	 -1.8	& 	-1.820		&	-1.786		\\\hline
$\delta$ 	&  	0.8		& 	0.480		&	0.748		\\
\end{tabular}

\begin{table}[htbp]

\begin{tabular}[h]{l|c|c|c}
											& DiffEq		& PySindy 			& Sindy naiv		\\\hline
Exakte Ableitung bekannt					& 	$0.040883$		&	$5.013162\cdot10^{-7}$	& 	$2.608947\cdot10^{-6}$	\\\hline
Ableitung über Zentraldifferenz 			& 	$0.167287$		&	$0.002317$			&	$0.002318$			\\\hline
Ableitung durch NN, sample interval 0.1s	& 	$0.212189$		&	$0.025098$			&	$0.025101$			\\\hline
Ableitung durch NN, sample interval 0.01s	& 	$0.135958$		&	$0.012395$			&	$0.012304$			\\\hline
Ableitung durch NN, sample interval 0.001s	& 	$0.126144$		&	$0.010833$			&	$0.010838$			\\
\end{tabular}													 
\caption{RMS des relativen Fehlers der Parameterschätzung, Lotka-Volterra-System}
\end{table}

\csvautotabular{images/errors_volterra.csv}\\
\csvautotabular{images/errors_lorenz.csv}\\
\csvautotabular{images/errors_roessler.csv}\\
\\
\csvautotabular{images/errors_volterra2.csv}\\
\csvautotabular{images/errors_lorenz2.csv}\\
\csvautotabular{images/errors_roessler2.csv}\\

anzahl der iterationen in pysindy relevant, wenn ident mit vorwissen, bei zentraldiff und lin term bekannt und $maxiter = 1$ kommt lin term hinzu, bei $maxiter = 2$ nicht\\
bei test mit NN fällt auf, dass sindy ergebnisse stark schwanken weil NN teilweise schlecht \\
problem bei relativem Fehler: wenn$ p_nom = 0$ und $p_ident != 0$ wie darstellen?\\
$\Xi_{alt}$ aus PySindy zu streichen macht den algorithmus kaputt\\

naiv ein wenig schlechter als pysindy?\\
abtastrate für zb lorenz von großer bedeutung für identifizierbarkeit, wie vergleichbar machen?\\
fehler in zentraldiff/NN festhalten, max oder durchschnitt?\\
sindy naiv: nach 2. mkq mit ausgewählten spalten nochmal alle coeff nullsetzen? in pysindy wird das nicht gemacht siehe roessler zentral $pi_zentral[2][8] = -6*10^{-5}$ wird aber nicht angezeigt\\
sparse regression ansatz schwierig bei systemen mit kleinen parametern zb roessler\\
vgl bei "high res" von X aus NN vs X aus odesolver\\
problem bei verkettung: sin(2x), parameter innerhalb von funktionen nicht in library darstellbar\\
bei wp: pysindy kann mittels choslesky zerlegung nicht reguläre matrix invertieren???\\
bei wp: durch mehrere 0 spalten in library pseudoinverse nicht mehr positiv definit, behoben durch +I, allerdings dann ergebnisse schlechter\\
test17\\
\section{Wagen-Pendel}
\subsection{mit Reibung}
\begin{align}
\dot{\vec{x}} &= \begin{pmatrix}
	x_1  \\
	x_2  \\
	x_3  \\ 
	x_4	
\end{pmatrix} 	=	\begin{pmatrix}
						\varphi \\
						x  \\
						\dot{\varphi}  \\ 
						\dot{x}
					\end{pmatrix} = f(\vec{x}) + g(\vec{x}) u\\
&=\begin{pmatrix}
	\dot{\varphi}  \\
	\dot{x}  \\
	-\frac{(m_1+m_2)R(\dot{\varphi}) + m_2^2s_2^2\dot{\varphi}^2\sin\varphi\cos\varphi + (m_1+m_2)gm_2s_2\sin\varphi}{m_2s_2^2(m_1 + m_2\sin^2\varphi)}\\
	\frac{R(\dot{\varphi})\cos\varphi + gm_2s_2\sin\varphi\cos\varphi + m_2s_2^2\dot{\varphi}^2\sin\varphi}{s_2(m_1+m_2\sin^2\varphi)}   
\end{pmatrix}		 +		 \begin{pmatrix}
								0  \\
								0  \\
								-\frac{m_2s_2\cos\varphi}{m_2s_2^2(m_1 + m_2\sin^2\varphi)}\\
								\frac{s_2}{s_2(m_1+m_2\sin^2\varphi)}   
							\end{pmatrix} F
\end{align}

\section{errors}
Ude:\\
$AssertionError: length(b) == length(variables(b)) in unknown_sys:$\\
wenn $\lambda$ so gewählt, dass ganze Zeilen rausfallen\\
nützliche Befehle: %$Juno.@enter SInDy(X[:, :], DX_[:, :], basis, λ, opt = opt, maxiter = 30, normalize = false, f_target = f_target)
%inv(A'*A)*A'Y
%inv([A[:,2] A[:,4]]'*[A[:,2] A[:,4]])*[A[:,2] A[:,4]]'*Y[:,1]
%inv([A[:,3] A[:,4]]'*[A[:,3] A[:,4]])*[A[:,3] A[:,4]]'*Y[:,2]
% ==================================
% Literaturverzeichnis
% ==================================

% Ein Literatureintrag, der nicht referenziert wird, aber im Verzeichnis erscheinen soll


% Literaturverzeichnis ausgeben
\printbibliography


\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
